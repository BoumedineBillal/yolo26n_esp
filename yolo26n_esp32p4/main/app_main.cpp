// YOLOv26n Inference on ESP32-P4 - Version 3 (Refactored with Yolo26Processor)
// Generated by Antigravity

#include "dl_model_base.hpp"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "yolo_processor.hpp" // New Refactored Processor

// Model binary
extern const uint8_t yolo26n_inference_espdl[] asm("_binary_yolo26n_512_espdl_start");

// Test images
extern const uint8_t bus_jpg_start[] asm("_binary_bus_jpg_start");
extern const uint8_t bus_jpg_end[] asm("_binary_bus_jpg_end");
extern const uint8_t person_jpg_start[] asm("_binary_person_jpg_start");
extern const uint8_t person_jpg_end[] asm("_binary_person_jpg_end");

void test_single_image(dl::Model *model, Yolo26Processor& processor, const uint8_t *jpg_start, const uint8_t *jpg_end, const char *image_name)
{
    printf("\n=== Testing: %s ===\n", image_name);
    
    // 1. Decode JPEG
    auto img = processor.decode_jpeg(jpg_start, (size_t)(jpg_end - jpg_start));
    
    auto resized_img = processor.resize(img, model->get_inputs());
    
    // 2. Preprocess (Measure Time)
    TickType_t start_pre = xTaskGetTickCount();
    processor.preprocess(resized_img, model->get_inputs());
    TickType_t end_pre = xTaskGetTickCount();
    
    // 3. Inference (Measure Time)
    TickType_t start_inf = xTaskGetTickCount();
    model->run();
    TickType_t end_inf = xTaskGetTickCount();

    // 4. Post-Process (Measure Time)
    TickType_t start_post = xTaskGetTickCount();
    auto results = processor.postprocess(model->get_outputs());
    TickType_t end_post = xTaskGetTickCount();

    // Calculate Latencies
    uint32_t lat_pre = (end_pre - start_pre) * portTICK_PERIOD_MS;
    uint32_t lat_inf = (end_inf - start_inf) * portTICK_PERIOD_MS;
    uint32_t lat_post = (end_post - start_post) * portTICK_PERIOD_MS;

    printf("Timings:\n");
    printf("  Pre-process:  %lu ms\n", (unsigned long)lat_pre);
    printf("  Inference:    %lu ms\n", (unsigned long)lat_inf);
    printf("  Post-process: %lu ms\n", (unsigned long)lat_post);
    printf("  Total:        %lu ms\n", (unsigned long)(lat_pre + lat_inf + lat_post));

    printf("\n--- Top Detections ---\n");
    int count = 0;
    for (const auto& det : results) {
        if (count >= 5) break;
        
        const char* class_name = "unknown";
        if (det.class_id >= 0 && det.class_id < 80) {
            class_name = coco_classes[det.class_id];
        }
        
        printf("Det %d: %s (%.2f%%) | Box: [%.1f, %.1f, %.1f, %.1f]\n", 
               count + 1,
               class_name,
               det.score * 100.0f,
               det.x1, det.y1, det.x2, det.y2);
        count++;
    }
    if (results.empty()) {
        printf("No detections above threshold %.2f\n", YOLO_CONF_THRESH);
    }

    if (resized_img.data != img.data) {
        heap_caps_free(resized_img.data);
    }
    heap_caps_free(img.data);
}

void run_inference_demo()
{
    printf("\n");
    printf("======================================================================\n");
    printf("  YOLOv26n Inference Demo v3 (Refactored Processor)\n");
    printf("======================================================================\n");
    
    // Load Model
    dl::Model *model = new dl::Model((const char *)yolo26n_inference_espdl, 
                                     fbs::MODEL_LOCATION_IN_FLASH_RODATA);
    
    // Init Processor (Stateful config)
    // Using default K=300, Thresh=0.10, COCO classes
    Yolo26Processor processor(YOLO_TARGET_K, YOLO_CONF_THRESH, coco_classes);

    // Run Tests
    test_single_image(model, processor, bus_jpg_start, bus_jpg_end, "bus.jpg");
    test_single_image(model, processor, person_jpg_start, person_jpg_end, "person.jpg");
    
    delete model;
    printf("\n=== Test Complete ===\n");
}

extern "C" void app_main(void)
{
    run_inference_demo();
}
